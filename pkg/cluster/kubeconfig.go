package cluster

import (
	"context"
	"io/ioutil"
	"net"
	"os"
	"path/filepath"
	"strings"

	dockertypes "github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	dockerclient "github.com/docker/docker/client"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"github.com/submariner-io/armada/pkg/defaults"
	"gopkg.in/yaml.v2"
)

type kubeConfig struct {
	APIVersion string `yaml:"apiVersion"`
	Clusters   []struct {
		Cluster struct {
			CertificateAuthorityData string `yaml:"certificate-authority-data"`
			Server                   string `yaml:"server"`
		} `yaml:"cluster"`
		Name string `yaml:"name"`
	} `yaml:"clusters"`
	Contexts []struct {
		Context struct {
			Cluster string `yaml:"cluster"`
			User    string `yaml:"user"`
		} `yaml:"context"`
		Name string `yaml:"name"`
	} `yaml:"contexts"`
	CurrentContext string `yaml:"current-context"`
	Kind           string `yaml:"kind"`
	Preferences    struct {
	} `yaml:"preferences"`
	Users []struct {
		Name string `yaml:"name"`
		User struct {
			ClientCertificateData string `yaml:"client-certificate-data"`
			ClientKeyData         string `yaml:"client-key-data"`
		} `yaml:"user"`
	} `yaml:"users"`
}

// PrepareKubeConfigs modifies the kubeconfig file generated by kind and copies it to the desired output file
func PrepareKubeConfigs(clusterName string, sourceKubeConfigFilePath, masterIP string) error {
	currentDir, err := os.Getwd()
	if err != nil {
		return errors.Wrap(err, "failed to get working directory.")
	}

	if err := os.MkdirAll(defaults.LocalKubeConfigDir, os.ModePerm); err != nil {
		return errors.Wrapf(err, "failed to create directory %q.", defaults.LocalKubeConfigDir)
	}

	if err := os.MkdirAll(defaults.ContainerKubeConfigDir, os.ModePerm); err != nil {
		return errors.Wrapf(err, "failed to create directory %q.", defaults.ContainerKubeConfigDir)
	}

	kindKubeFileName := strings.Join([]string{"kind-config", clusterName}, "-")
	newLocalKubeFilePath := filepath.Join(currentDir, defaults.LocalKubeConfigDir, kindKubeFileName)
	newContainerKubeFilePath := filepath.Join(currentDir, defaults.ContainerKubeConfigDir, kindKubeFileName)

	sourceKubeFile, err := ioutil.ReadFile(sourceKubeConfigFilePath)
	if err != nil {
		return errors.Wrapf(err, "failed to read kube config file %q.", sourceKubeConfigFilePath)
	}

	var kubeconf kubeConfig
	err = yaml.Unmarshal(sourceKubeFile, &kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to unmarshal contents from kube config file %q.", sourceKubeConfigFilePath)
	}

	kubeconf.CurrentContext = clusterName
	kubeconf.Contexts[0].Name = clusterName
	kubeconf.Contexts[0].Context.Cluster = clusterName
	kubeconf.Contexts[0].Context.User = clusterName
	kubeconf.Clusters[0].Name = clusterName
	kubeconf.Users[0].Name = clusterName

	marshalled, err := yaml.Marshal(&kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to marshal kube config %#v.", kubeconf)
	}

	err = ioutil.WriteFile(newLocalKubeFilePath, marshalled, 0644)
	if err != nil {
		return errors.Wrapf(err, "failed to save kube config %q.", newLocalKubeFilePath)
	}

	kubeconf.Clusters[0].Cluster.Server = "https://" + masterIP + ":6443"
	marshalled, err = yaml.Marshal(&kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to marshal kube config %#v.", kubeconf)
	}

	err = ioutil.WriteFile(newContainerKubeFilePath, marshalled, 0644)
	if err != nil {
		return errors.Wrapf(err, "failed to save kube config %q.", newContainerKubeFilePath)
	}
	return nil
}

// GetKubeConfigPath returns different kubeconfig paths for local and docker based runs
func GetKubeConfigPath(clusterName string) (string, error) {
	currentDir, err := os.Getwd()
	if err != nil {
		return "", errors.Wrap(err, "failed to get working directory.")
	}

	// Dummy destination
	address := "1.1.1.1:80"
	conn, err := net.Dial("udp", address)
	if err != nil {
		return "", errors.Wrapf(err, "failed to connect to address %q.", address)
	}
	defer conn.Close()

	localAddr := conn.LocalAddr().(*net.UDPAddr)
	ctx := context.Background()
	dockerCli, err := dockerclient.NewEnvClient()
	if err != nil {
		return "", errors.Wrap(err, "failed to create docker client.")
	}

	networkFilter := filters.NewArgs()
	networkFilter.Add("driver", "bridge")
	networks, err := dockerCli.NetworkList(ctx, dockertypes.NetworkListOptions{Filters: networkFilter})
	if err != nil {
		return "", errors.Wrap(err, "failed to list the networks configured in the docker host.")
	}

	for _, network := range networks {
		dockerNet := network.IPAM.Config[0].Subnet
		_, ipNet, err := net.ParseCIDR(dockerNet)
		if err != nil {
			return "", errors.Wrapf(err, "failed to parse network CIDR %q.", dockerNet)
		}

		if ipNet.Contains(localAddr.IP) {
			log.Debugf("Running in a container with bridge network %q, IP %q", dockerNet, localAddr.IP)
			kubeConfigFilePath := filepath.Join(currentDir, defaults.ContainerKubeConfigDir, strings.Join([]string{"kind-config", clusterName}, "-"))
			return kubeConfigFilePath, nil
		}
	}

	log.Debugf("Running in a host mode with IP %q", localAddr.IP)
	kubeConfigFilePath := filepath.Join(currentDir, defaults.LocalKubeConfigDir, strings.Join([]string{"kind-config", clusterName}, "-"))
	return kubeConfigFilePath, nil
}
